GIỚI THIỆU VỀ LINQ TRONG C#
1. LINQ là gì?
- LINQ (Language Integrated Query) là công cụ truy vấn dữ liệu tích hợp ngay trong C#, cho phép thao tác trên các tập dữ liệu (mảng, danh sách, dictionary, XML, database…) bằng cú pháp ngắn gọn, rõ ràng và an toàn kiểu dữ liệu.
- LINQ hoạt động dựa trên IEnumerable<T> hoặc IQueryable<T>.
- Cách hiểu đơn giản: LINQ là “ngôn ngữ SQL thu nhỏ” nằm trong C#, giúp bạn chỉ cần mô tả “bạn muốn gì”, còn .NET sẽ tự xử lý vòng lặp, kiểm tra điều kiện và trả kết quả.

- LINQ trong game / Unity. Bạn có thể áp dụng LINQ lên:
+ GameObject[]
+ Transform[]
+ Component[]
+ List<T>
+ Bất kỳ IEnumerable<YourType>

- Lợi ích
+ Viết code ngắn hơn, dễ đọc hơn. Thay vì lặp qua mảng bằng for/foreach rồi kiểm if, bạn chỉ cần một dòng .Where() hoặc .Select().
+ Cú pháp kiểu declarative đễ đọc, tiện bảo trì giúp bạn nhấn mạnh vào "điều bạn muốn" thay vì "cách bạn thực hiện".
+ Bạn hoàn toàn có thể ghép nối, thêm bớt, thay thế, tổ hợp các truy vấn mà không cần viết lại cấu trúc lặp từ đầu.
+ An toàn kiểu dữ liệu (type-safe).

- Như vậy, LINQ phù hợp khi bạn:
+ Muốn xử lý collection một cách tiện dụng, súc tích.
+ Muốn viết code rõ ràng, bảo trì về sau tiện dụng.
+ Muốn khắc các cấu trúc if/for phức tạp bằng một dòng trí tuệ.

* Ví dụ:

- Cách truyền thống
GameObject[] gos = GameObject.FindObjectsOfType<GameObject>();
foreach (var go in gos)
{
      if (go.activeInHierarchy)
      {
            Debug.Log(go.name);
       }
}

Ở đoạn code này:
• Chúng ta đóng khung, kiểm, lọc hoàn toàn bằng for/foreach.
• Nếu muốn thêm điều kiện hoặc thay đổi, bạn sẽ cần thêm if hoặc if-else

- Dùng LINQ:
var activeNames = GameObject.FindObjectsOfType<GameObject>().Where(go => go.activeInHierarchy).Select(go => go.name);
foreach (var name in activeNames)
{
      Debug.Log(name);
}

Ở đoạn code này:
• Where(go => go.activeInHierarchy): Filter trực tiếp mà không cần if.
• Select(go => go.name): Chuyển GameObject sang string.
• activeNames lúc này là IEnumerable<string>: hoàn toàn tiện dụng để tiếp tục xử lý nếu muốn.

2. Hai kiểu cú pháp của LINQ
2.1 Method Syntax (Cú pháp phương thức, phổ biến nhất)
- Method Syntax là cách bạn sử dụng trực tiếp các phương thức như Where, Select, OrderBy… bằng cách chấm (.) sau collection. 
- Hiện tại, đa số lập trình viên Unity, C# đều ưa chuộng kiểu này bởi cú pháp gọn, tiện dụng, trực quan.

Ví dụ:
var result = collection
    .Where(x => x.hp > 50)
    .OrderBy(x => x.name)
    .Select(x => x);

2.2 Query Syntax (Cú pháp truy vấn, giống SQL)
- Query Syntax không trực tiếp gọi phương mà sử dụng cấu trúc tương đồng với SQL. 
- Cách này chủ yếu tiện dụng khi bạn bắt đầu quen với LINQ hoặc muốn dịch trực tiếp từ SQL sang.

Ví dụ:
var result = from x in collection
             where x.hp > 50
             orderby x.name
             select x;


Cả hai cho kết quả giống nhau, chỉ khác phong cách viết.

3. Cơ chế thực thi
- Deferred Execution (trì hoãn): Truy vấn chỉ chạy khi bạn duyệt kết quả, ví dụ:
+ foreach
+ .ToList()
+ .Count()

- Immediate Execution (tức thời): Chạy ngay lập tức:
+ ToList(), ToArray()
+ Count(), Sum()
+ First(), FirstOrDefault()

4. Các toán tử LINQ cơ bản
4.1 Where — Where dùng để lọc và lấy ra các phần tử trong Collection thoả mãn một điều kiện. 
Ví dụ:
// Lọc và lấy ra các GameObject có tag “Enemy”.
var enemies = FindObjectsOfType<GameObject>().Where(go => go.CompareTag("Enemy"));

4.2 Select — Select dùng để chọn 1 thuộc tính và lấy ra thuộc tính đó từ tất cả các phần tử trong Collection

Ví dụ:
// Lấy ra thuộc tính name của tất cả các GameObject
IEnumerable<string> names = FindObjectsOfType<GameObject>().Select(go => go.name);

4.3 First / FirstOrDefault
- First dùng để lấy ra phần tử đầu tiên trong Collection phù hợp với điều kiện truyền vào, nếu không tìm thấy sẽ ném Exception
- FirstOrDefault dùng để lấy ra phần tử đầu tiên trong Collection phù hợp với điều kiện truyền vào, nếu không tìm thấy sẽ trả về null

Ví dụ:
// Nếu tìm được GameObject nào có tag Enermy, trả về luôn GameObject đó, nếu không tìm thấy thì trả về null
GameObject firstEnemy = FindObjectsOfType<GameObject>().FirstOrDefault(go => go.CompareTag("Enemy"));

4.4 OrderBy / OrderByDescending
- OrderBy dùng để sắp xếp tăng dần 1 Collection theo 1 thuộc tính của các phần tử trong Collection
- OrderByDescending dùng để sắp xếp giảm dần 1 Collection theo 1 thuộc tính của các phần tử trong Collection

Ví dụ:
// Sắp xếp các GameObject từ gần đến xe điểm (0, 0, 0)
var enemiesByDistance = FindObjectsOfType<GameObject>().Where(go => go.CompareTag("Enemy")).OrderBy(go => Vector3.Distance(go.transform.position, Vector3.zero));

4.5 Count — Count giúp đếm số lượng phần tử thoả màn một điều kiện

Ví dụ:
// Đếm số lượng GameObject có tag Enermy
int numberOfEnemies = FindObjectsOfType<GameObject>().Count(go => go.CompareTag("Enemy"));

5. Các toán tử nâng cao
5.1 GroupBy — GroupBy dùng để gom nhóm đối tượng theo 1 thuộc tính

Ví dụ:
var enemiesByTag = FindObjectsOfType<GameObject>().Where(go => go.CompareTag("Enemy")).GroupBy(go => go.tag);

foreach (var group in enemiesByTag)
{
    Debug.Log($”Group {group.Key} has {group.Count()} items.”);
}

5.2 Distinct — Distinct giúp lấy ra các phần tử chỉ xuất hiện 1 lần trong Collection

Ví dụ:
// Lấy ra những tag chỉ xuất hiện 1 lần
IEnumerable<string> uniqueTags = FindObjectsOfType<GameObject>().Select(go => go.tag).Distinct();

5.3 Skip / Take 
- Skip giúp bỏ qua một số lượng phần tử lúc bắt đầu
- Take giúp lấy tiếp một số lượng phần tử sau khi Skip

Ví dụ:
// Bỏ qua 5 Enermy đầu tiên, lấy 10 Enermy tiếp theo
var subset = FindObjectsOfType<GameObject>().Where(go => go.CompareTag("Enemy")).Skip(5).Take(10);

5.4 All — All dùng để kiểm tra xem tất cả các phần tử trong Collection có thoả mãn 1 điều kiện không

Ví dụ:
// Kiểm tra xem tất cả Enermy có đang Active không 
bool allEnemiesAlive = enemies.All(go => go.activeInHierarchy);

5.5 Any — Any dùng để kiểm tra xem trong Collection có ít nhất 1 phần tử thoả mãn 1 điều kiện không 

Ví dụ:
// Kiểm tra xem trong các Enermy có Boss không 
bool hasBoss = enemies.Any(go => go.name.Contains("Boss"));

5.6 Contains — Contains dùng để kiểm tra xem trong Collection có chứa 1 phần tử nào đó không .

Ví dụ:
// Kiểm tra xem 1 player có nằm trong Collection không .
bool containsPlayer = players.Contains(player);

5.7 Min / Max 
- Min dùng để trả về giá trị nhỏ nhất của 1 Collection, có thể truyền vào 1 thuộc tính để tìm phần tử có giá trị thuộc tính đó nhỏ nhất.
- Max dùng để trả về giá trị lớn nhất của 1 Collection, có thể truyền vào 1 thuộc tính để tìm phần tử có giá trị thuộc tính đó lớn nhất.

Ví dụ:
// Tìm khoảng cách lớn nhất và nhỏ nhất từ 1 Enermy đến điểm (0, 0, 0).
float minDistance = enemies.Min(go => Vector3.Distance(go.transform.position, Vector3.zero));
float maxDistance = enemies.Max(go => Vector3.Distance(go.transform.position, Vector3.zero));

6. Ví dụ thực tế trong game
6.1 Lọc kẻ địch mạnh (HP > 50)
var strong = enemies.Where(e => e.HP > 50);

6.2 Tính tổng vàng
int totalGold = golds.Sum();

6.3 Tìm quái yếu nhất – mạnh nhất
var weakest = enemies.Min(e => e.HP);
var strongest = enemies.Max(e => e.HP);

6.4 Lọc boss, sắp xếp theo HP giảm dần
var bosses = enemies
    .Where(e => e.IsBoss)
    .OrderByDescending(e => e.HP)
    .Select(e => e.Name);

6.5 Group kẻ địch theo loại (Melee / Ranged)
var groups = enemies.GroupBy(e => e.Type);

foreach (var group in groups)
{
    Console.WriteLine($"== {group.Key} ==");
    foreach (var enemy in group)
        Console.WriteLine($"- {enemy.Name} ({enemy.HP} HP)");
}

7. Lưu ý quan trọng khi dùng LINQ trong Unity (hiệu năng)
- LINQ tạo allocations → sinh rác → tốn GC.
- Không dùng LINQ trong:
+ Update()
+ FixedUpdate()
+ LateUpdate()

- Nên sử dụng ToList(), ToArray() (Gọi là Materialize), để chuyển kết quả từ 1 truy vấn sang dạng danh sách, tránh sử dụng truy vấn nhiều lần.
Ví dụ:
var list = enemies.Where(e => e.HP > 0).ToList();

8. Khi nào nên dùng LINQ?
Nên dùng khi:
- Lọc dữ liệu (Enemy, Item, Buff…)
- Sắp xếp, thống kê
- Setup dữ liệu ban đầu (không chạy hàng frame)
- Code cần rõ ràng, dễ đọc

Không nên dùng khi:
- Trong vòng lặp gọi mỗi frame
- Logic ảnh hưởng hiệu năng trực tiếp
